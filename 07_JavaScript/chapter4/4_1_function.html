<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- * -->
  <button type="button" onclick="changeColor()">배경색 바꾸기</button>

  <hr>

  <!-- ** -->
  <input type="text" id="id" placeholder="아이디" aria-label="아이디">
  <input type="password" id="pw" placeholder="비밀번호" aria-label="비밀번호">
  <button type="button" class="btn-login">로그인</button>

  <hr>

  <!-- *** -->
  <div>
    <p>
      <button type="button" onclick="gallery('PREV')">이전</button>
      <button type="button" onclick="gallery('NEXT')">다음</button>
    </p>
    <p>
      <img src="./images/pic_1.jpg" alt="포토" class="photo">
    </p>
  </div>

  <hr>
  <script>
    // 함수
    // 기능(동작)을 수행하는 여러 실행 코드들의 묶음(그룹화)
    // 자주 사용하는 코드들(기능)을 저장했다가 필요할 때 호출해서 사용
    // 즉, 변수와 마찬가지로 한번 선언해두고 재사용이 가능
    // function 키워드를 사용하여 정의 => ES6차에서는 화살표 함수를 사용

    // 함수의 선언과 호출
    // 1) 함수 선언문 : 기명 함수로 정의
    function 함수명(매개변수) {
      실행코드;
    }

    // 2) 함수 표현식 : 익명 함수를 변수에 할당
    const 변수 = function (매개변수) {
      실행코드;
    }

    // 매개변수(옵셔널): 외부로부터 전달받은 값(데이터)을 저장
    // 중괄호 블록({}): 블록 안에 실행할 코드들을 작성
    // 선언이 끝나면 필요한 곳에서 호출해서 사용
    // 위와 같이 정의된 함수는 즉시 실행되지 않음
    // 메모리에 할당되어 있다가 함수가 호출되면 블록 안에 여러 코드들이 한번에 실행됨
    // 1) 함수명();
    // 2) 변수명();

    function greeting() {
      document.write('hello<br>');
    }
    greeting();
    greeting();
    greeting();

    // (참고) 함수 선언문과 함수 표현식의 차이점
    // 함수 선언문은 호이스팅(끌어올리기)이 일어난다.
    // 해당 스코프(유효범위)의 최상단으로 끌어올려진 것과 같은 현상(실제로 끌어올리는 것은 아님)
    // 변수나 함수 선언이 코드 실행보다 먼저 메모리에 할당(저장)되는 과정
    // Point! 선언만 호이스팅 대상(초기화를 제외한 선언만 호이스팅)
    let count = 0;

    myFunc();
    
    function myFunc() {
      count++;
      document.write(`hello ${count}<br>`);
    }
    
    myFunc();
    
    // theFunc(); // 초기화 전에는 쓸 수 없음
    
    const theFunc = function() {
      count++;
      document.write(`hello ${count}<br>`);  
    }

    theFunc();

    // 버튼 클릭할 때마다 배경색이 바뀌도록 함수 만들기
    // (위에 body 태그 참조*)
    const colors = ['yellow', 'aqua', 'purple', 'white', 'pink'];
    
    const bodyTag = document.querySelector('body');
    let index = 0;

    function changeColor() {
      // Quiz : index가 4이상일 때 다시 0부터 시작
      if (index >= colors.length) index = 0;
      bodyTag.style.backgroundColor = colors[index++];
    }

    // 3) 매개변수가 있는 함수
    // 매개변수는 유효 범위(scope)인 함수 내에서만 사용 가능!
    // function 함수명(매개변수1, 매개변수2, ...) {
    //   실행코드;
    // }
    // 함수명(인자값1, 인자값2, ...);
    // function introduce(name, area) { // 외부에서 받을 데이터가 있으면 매개변수(Parameters) 선언
    function introduce(name, area = '대한민국') { // ES6차
      document.write(`안녕하세요. ${name}입니다.<br>`);
      document.write(`사는 곳은 ${area}입니다.<br>`);
    }
    introduce('홍길동', '서울'); // 인수(인자 값, 매개값, Arguments)를 전달
    introduce('홍길동'); // 꼭 인자 값 수를 맞출 필요는 없음! 
    introduce('홍길동', '서울', '무의미한 데이터'); 

    // 로그인 함수 만들기
    const dbUser = {
      id: 'teng',
      pw: '1234',
      name: '홍길동'
    };

    // 위에 ** 참조
    const inputId = document.querySelector('#id');
    const inputPw = document.querySelector('#pw');
    const btnLogin = document.querySelector('.btn-login');

    btnLogin.addEventListener('click', function () { // 익명 함수
      login(inputId.value, inputPw.value);
    });

    // Quiz: login 함수 선언하고 호출하기
    // 잘못된 id입력: alert('존재하지 않는 아이디입니다.');
    // 잘못된 pw입력: alert('잘못된 비밀번호입니다.');
    // 로그인 성공 시: alert('~~~님 방문을 환영합니다!');

    function login(inputId, inputPw) {
      if (inputId !== dbUser.id) alert('존재하지 않는 아이디입니다.'); 
      else if (inputPw !== dbUser.pw) alert('잘못된 비밀번호입니다.');
      else alert(dbUser.name + '님 방문을 환영합니다!');
      
      // early return 패턴 적용
      // if (inputId !== dbUser.id) {
      //   alert('존재하지 않는 아이디입니다.');
      //   return;
      // } 
      
      // if (inputPw !== dbUser.pw) {
      //   alert('잘못된 비밀번호입니다.');
      //   return;
      // }

      // alert(dbUser.name + '님 방문을 환영합니다!');
    }

    // 4) 함수에서 return문의 역할
    // 데이터(결과값)를 반환
    // 함수를 강제 종료
    // function 함수명() {
    //   실행코드;
    //   return 값;
    //   return; // return만 쓰면 함수 종료를 의미
    //   실행코드2; (실행X)
    // }

    // Quiz : 여러 과목의 점수를 입력받아 평균 점수 구하기
    const subjects = ['국어', '영어', '수학'];

    // function testAvg(arrData) {
    //   let sum = 0;
    //   // 배열의 길이만큼 정수를 입력받기
    //   for (let i = 0; i < arrData.length; i++) {
    //     sum += Number(prompt(arrData[i] + ' 점수를 입력하세요', '0'));
    //   }

    //   return sum / arrData.length;
    // }
    // document.write(`평균 점수는 ${testAvg(subjects)}점 입니다.<br>`);

    // Quiz : 이전/다음 버튼으로 이미지를 넘기는 gallery() 함수 만들기
    // body 태그 *** 참조
    // 힌트 :
    // 1. 이전/다음 버튼을 구분할 수 있도록 임의의 매개값 전달하기
    // 2. HTML img 태그(요소)를 JS DOM 객체로 가져온 후
    // DOM 프로퍼티(property)인 src 속성을 이용하거나
    // HTML 속성(attribute)을 추가하는 setAttribute() 메소드 이용
    const img = document.querySelector('.photo');
    let imgNum = 1;

    function gallery(direction) {
      if (direction === 'PREV' && imgNum > 1) imgNum--;
      else if (direction === 'NEXT' && imgNum < 8) imgNum++;

      img.src = `./images/pic_${imgNum}.jpg`;
      // img.setAttribute('src', `./images/pic_${imgNum}.jpg`);
    }

    // 5) 기명(이름이 있는) 함수와 익명(이름이 없는) 함수
    // 일반적으로 함수에는 이름이 존재하지만 때로는 없을 수도 있음
    // 함수는 그 자체가 하나의 값(데이터)으로 취급되어 변수에 할당 가능
    // 이 때는 변수의 이름이 곧 함수의 이름이 된다.

    // 기명 함수
    // 함수 선언문
    function hello() {
      console.log('Hello ~');
    }
    hello();

    // 익명 함수
    // 함수 표현식
    // 익명 함수는 이름이 없기 때문에 변수에 할당하지 않으면 재사용 불가
    const world = function () {
      console.log('World ~');
    }
    world();

    // 익명 함수 활용 예
    // 함수를 재사용할 필요가 없으면(1회성) 굳이 이름 붙이지 않고 익명 함수 사용
    // JS에서 함수는 그 자체가 하나의 값(데이터)이라 함수를 호출할 때 인자 값으로 사용 가능
    document.body.addEventListener('click', function () {
      console.log('1회성 함수!!!');
    });
    // 보통 이벤트 핸들러는 1회성 기능이므로 익명 함수로 만듦

    // 6) 메소드에 대해
    // 객체에 저장하는 데이터가 함수인 경우, 그 속성을 메소드라고 부름
    const user = {
      name: 'goni',
      age: 55,
      // 여기서 getName은 메소드이고 값으로 익명 함수를 저장
      getName: function () {
        return this.name;
      }
    };
    // this는 객체 자기 자신을 가리키는 키워드
    // 자신이 속한 객체의 각 속성에 this로 접근 가능(객체 내부에서 접근 시)

    const hisName = user.getName();
    console.log(hisName);
    console.log(user.getName());

    // 7) 스코프(유효 범위) 개념
    // 변수 또는 함수의 사용 가능한 유효 범위
    // 전역 스코프: 코드의 어느 곳에서나 접근 가능
    // 블록 스코프: 선언된 블록 내부에서만 접근 가능
    // 여기에서 블록은 함수, 조건문, 반복문 등 중괄호({})로 구분되는 모든 영역을 의미

    // 전역 변수와 지역 변수
    const globalNum = 50; // 전역 변수

    function testVarScope() {
      const localNum = 200; // 지역 변수
      document.write(`함수 안 : ${globalNum}<br>`);
      document.write(`함수 안 : ${localNum}<br>`);
    }
    testVarScope();

    document.write(`함수 안 : ${globalNum}<br>`);
    // document.write(`함수 안 : ${localNum}<br>`); // localNum is not defined 

    // 전역과 지역을 나누는 이유?
    // 변수명(또는 비슷한 기능의 함수명)의 충돌을 피하기 위해
    // 해당 데이터가 전체에서 쓰인다면 전역 변수로, 함수 내 또는 제어문 내에서만 쓰이면 지역 변수로 선언
    // 지역 변수의 예 : for문의 초기화식, 함수의 매개변수

    // 8) 내장 함수
    // 자바스크립트 엔진에 내장되어 바로 호출 가능한 함수
    
    // 문자열 데이터를 정수형 데이터로 반환
    console.log(parseInt('10.33')); // 10
    console.log(parseInt('15.5px')); // 15
    console.log(parseInt('a40')); // NaN
    console.log(parseInt(true)); // NaN

    // 문자열 데이터를 실수형 데이터로 반환
    console.log(parseFloat('10.33')); // 10.33
    console.log(parseFloat('15.5px')); // 15.5
    console.log(parseFloat('a40')); // NaN
    console.log(parseFloat(true)); // NaN

    // 문자형 데이터로 반환
    console.log(String(5)); // '5'
    console.log(String([1, 2, 3, 4])); // '1,2,3,4'
    console.log(String(new Date())); // Sat Jan 07 2023 19:12:03 GMT+0900 (한국 표준시)

    // 숫자형 데이터로 반환(숫자형으로 바꿀수 없으면 NaN을 반환)
    console.log(Number('5')); // 5
    console.log(Number(true)); // 1
    console.log(Number(false)); // 0
    console.log(Number('abc')); // NaN

    // 논리형 데이터로 반환
    // false 값들: false, 0(-0), ''(""), undefined, null, NaN
    console.log(Boolean(5)); // true
    console.log(Boolean(null)); // false
    console.log(Boolean(10 > 9)); // true

    // NaN(Not-a-Number) 값이면 true를 반환
    console.log(isNaN(5)); // false
    console.log(isNaN(5 - 2)); //false
    console.log(isNaN('123')); // false, 테스트하기 전에 값을 숫자로 변환
    console.log(isNaN('Hello')); // true

    // (참고) 대문자로 시작하는 내장 함수 = 생성자 함수
    // new 키워드와 함께 생성자도 되고, new 없이 그냥 형변환 함수처럼도 동작하는 특수한 생성자 함수
  </script>
</body>
</html>